#!/usr/bin/env python

"""
This is a Python version of libRadtran/src/phase.c

!!!!!!!!!!!!!!!!!!!!!
! Incomplete        !
! Under development !
!!!!!!!!!!!!!!!!!!!!!

by Hong Chen (hong.chen.cu@gmail.com)
"""


import numpy as np
import er3t.common



def get_phase(
        wvl0 = 555.0,
        angles=np.concatenate((
            np.arange(  0.0,   2.0, 0.01),
            np.arange(  2.0,   5.0, 0.05),
            np.arange(  5.0,  10.0, 0.1),
            np.arange( 10.0,  15.0, 0.5),
            np.arange( 15.0, 176.0, 1.0),
            np.arange(176.0, 180.1, 0.25),
        )),
        fname_pha='%s/wc.sol.mie.cdf' % er3t.common.fdir_data_pha,
        ):

    try:
        from netCDF4 import Dataset
    except ImportError:
        msg = 'Error [phase]: Please install <netCDF4> to proceed.'
        raise ImportError(msg)

    f    = Dataset(fname_pha, 'r')
    wvl  = f.variables['wavelen'][:] * 1000.0
    cer  = f.variables['reff'][:]
    ssa  = f.variables['ssa'][:].T
    pmom = f.variables['pmom'][:].T[:, 0, :, :]
    asy  = pmom[1, :, :]/3.0

    Npoly, Ncer, Nwvl = pmom.shape

    Nang = angles.size
    pha = np.zeros((Nang, Ncer), dtype=np.float64)

    iwvl = np.argmin(np.abs(wvl-wvl0))

    for icer in range(Ncer):
        pmom0 = pmom[:, icer, iwvl]
        polys = pmom0/(2.0*np.arange(Npoly)+1.0)

        xx, yy, tmp = legendre2phase(polys, deltascaling=True)
        pha[:, icer] = np.interp(angles, xx, yy)
        print(icer)

    f.close()

    f = h5py.File('test_phase.h5', 'w')
    f['pha'] = pha
    f['cer'] = cer
    f['ang'] = angles
    # f['ssa'] = ssa[:, iwvl]
    # f['asy'] =
    f.close()


def legendre2phase(
        polys,
        deltascaling=True,
        normalize=False,
        step=0.01,
        ):

    Npoly = polys.size
    if deltascaling:
        polys = (polys-polys[-1])/(1.0-polys[-1])

    polys *= (2.0*np.arange(Npoly)+1.0)

    if normalize:
        factors = 1.0/polys[0]
        polys *= factors

    angle = np.arange(0.0, 180.0+step, step)
    mu    = np.cos(np.deg2rad(angle))

    phase     = np.zeros_like(mu)
    phase_int = np.zeros_like(mu)

    for i, mu0 in enumerate(mu):
        phase[i]     = mom2phase(polys, mu0)
        phase_int[i] = mom2phaseint(polys, mu0)

    return angle, phase, phase_int



def mom2phase(polys, mu):

    """
    Purpose: calculate phase function from phase function moments.
             Adapted from libRadtran/libsrc_c/miecalc.c:<mom2phase>
             by Bernhard Mayer

    Inputs:
        polys: Legendre moment vector
        mu: cosine angles

    Output:
        phase function

    by Hong Chen (hong.chen.cu@gmail.com)
    """

    plm1 = mu
    plm2 = 1.0

    pha = plm2*polys[0] + plm1*polys[1]

    Npoly = polys.size
    for i in range(2, Npoly):
        plm0 = ((2.0*i - 1.0)*mu*plm1 - (i-1)*plm2) / i

        pha += polys[i] * plm0

        plm2 = plm1
        plm1 = plm0

    return pha



def mom2phaseint(polys, mu):

    """
    Purpose: Calculate integral of the phase function from -1 to x from the phase function moments
             Adapted from libRadtran/src/phase.c:<mom2phaseint>

    Inputs:
        polys: Legendre moment vector
        mu: cosine angles

    Output:
        pha_int: Integral of phase function

    by Hong Chen (hong.chen.cu@gmail.com)
    """

    plm1 = mu
    plm2 = 1.0

    pldashm1 = 1.0
    pldashm2 = 0.0

    pha_int = (1.0 - mu)*polys[0] + 0.5*(1.0 - mu**2) * polys[1]

    Npoly = polys.size
    for i in range(2, Npoly):
        plm0     = ((2.0*i - 1.0)*mu*plm1 - (i-1)*plm2) / i
        pldashm0 = ((2.0*i - 1.0)*(plm1 + mu*pldashm1) - (i-1)*pldashm2) / i

        pha_int += polys[i] * (1.0 - mu**2) / (i * (i+1))*pldashm0

        plm2 = plm1
        plm1 = plm0

        pldashm2 = pldashm1
        pldashm1 = pldashm0

    return pha_int


if __name__ == '__main__':

    get_phase()
